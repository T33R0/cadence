<!DOCTYPE html>
<html>
<head>
<title>Cadence Avatar Preview</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0A0A0F; color: #e2e8f0; font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 40px; gap: 30px; }
h1 { font-size: 14px; letter-spacing: 2px; text-transform: uppercase; color: #64748b; }
.row { display: flex; gap: 40px; align-items: center; }
.state { display: flex; flex-direction: column; align-items: center; gap: 12px; }
.label { font-size: 11px; color: #94a3b8; letter-spacing: 1px; text-transform: uppercase; }
canvas { border-radius: 50%; }
</style>
</head>
<body>
<h1>Cadence Avatar â€” All States</h1>
<div class="row">
  <div class="state"><canvas id="idle" width="300" height="300"></canvas><span class="label">idle</span></div>
  <div class="state"><canvas id="online" width="300" height="300"></canvas><span class="label">online</span></div>
  <div class="state"><canvas id="thinking" width="300" height="300"></canvas><span class="label">thinking</span></div>
  <div class="state"><canvas id="success" width="300" height="300"></canvas><span class="label">success</span></div>
  <div class="state"><canvas id="error" width="300" height="300"></canvas><span class="label">error</span></div>
</div>
<script>
const CAD = { base: "#00E5CC", violet: "#7B61FF", green: "#00FF88", red: "#FF3D5A", orange: "#FF8800", bg: "#0A0A0F" };
const SIZE = 300;

function createAvatar(canvasId, status) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext("2d");
  const cx = SIZE / 2, cy = SIZE / 2;
  const ringR = SIZE * 0.30;
  const tubeR = SIZE * 0.055;
  const TILT_X = 0.26;
  const SEGMENTS = 180;
  let startTime = 0;

  const particles = [];
  for (let i = 0; i < 18; i++) {
    particles.push({
      angle: Math.random() * Math.PI * 2,
      vAngle: (0.001 + Math.random() * 0.003) * (Math.random() > 0.5 ? 1 : -1),
      dist: ringR * 0.3 + Math.random() * ringR * 0.4,
      sz: 1 + Math.random() * 2,
      opacity: 0.3 + Math.random() * 0.4,
    });
  }

  let successPingT = -1;

  function getParams(s) {
    if (s === "thinking") return { rotSpeed: Math.PI * 2 / 4, pulseFreq: 2.5, pulseAmp: 0.7, color: [123, 97, 255], glowI: 1.4, harm2: 0.35, pCount: 18, orbit: true };
    if (s === "success") return { rotSpeed: Math.PI * 2 / 8, pulseFreq: 1.0, pulseAmp: 0.4, color: [0, 229, 204], glowI: 1.6, harm2: 0, pCount: 8, orbit: false };
    if (s === "error") return { rotSpeed: Math.PI * 2 / 8, pulseFreq: 4.0, pulseAmp: 1.0, color: [255, 61, 90], glowI: 1.2, harm2: 0, pCount: 5, orbit: false };
    if (s === "idle") return { rotSpeed: Math.PI * 2 / 8, pulseFreq: 1.0, pulseAmp: 0.25, color: [0, 160, 143], glowI: 0.5, harm2: 0, pCount: 6, orbit: false };
    return { rotSpeed: Math.PI * 2 / 8, pulseFreq: 1.0, pulseAmp: 0.35, color: [0, 229, 204], glowI: 1.0, harm2: 0, pCount: 8, orbit: false };
  }

  function draw(ts) {
    if (!startTime) startTime = ts;
    const elapsed = (ts - startTime) / 1000;
    const p = getParams(status);
    ctx.clearRect(0, 0, SIZE, SIZE);
    ctx.fillStyle = CAD.bg;
    ctx.fillRect(0, 0, SIZE, SIZE);

    const yOsc = Math.sin(elapsed * Math.PI * 2 / 4) * 2;
    const ccy = cy + yOsc;
    const rotAngle = elapsed * p.rotSpeed;

    // Aura
    const auraGrad = ctx.createRadialGradient(cx, ccy, ringR * 0.6, cx, ccy, (ringR + tubeR * 1.15) * 1.3);
    auraGrad.addColorStop(0, `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${0.06 * p.glowI})`);
    auraGrad.addColorStop(0.6, `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${0.03 * p.glowI})`);
    auraGrad.addColorStop(1, "transparent");
    ctx.fillStyle = auraGrad;
    ctx.beginPath(); ctx.arc(cx, ccy, (ringR + tubeR * 1.15) * 1.3, 0, Math.PI * 2); ctx.fill();

    // Torus ring
    const lightAngle = -Math.PI * 0.75;
    for (let i = 0; i < SEGMENTS; i++) {
      const a1 = (i / SEGMENTS) * Math.PI * 2;
      const tiltY1 = Math.sin(a1) * TILT_X;
      const pulsePhase = a1 - elapsed * p.pulseFreq * Math.PI * 2;
      const disp = Math.sin(pulsePhase) * p.pulseAmp * tubeR;
      const disp2 = Math.sin(pulsePhase * 2.3 + 0.5) * p.harm2 * tubeR;
      let errorSpike = 0;
      if (status === "error") {
        const sawPhase = ((a1 - elapsed * 8) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
        errorSpike = sawPhase < 1.0 ? (1 - sawPhase) * tubeR * 1.5 : 0;
      }
      const totalDisp = disp + disp2 + errorSpike;
      const ra1 = a1 + rotAngle;
      const ra2 = ((i + 1) / SEGMENTS) * Math.PI * 2 + rotAngle;
      const x1 = cx + Math.cos(ra1) * (ringR + totalDisp);
      const y1 = ccy + Math.sin(ra1) * (ringR + totalDisp) * (1 - TILT_X * 0.3);
      const x2 = cx + Math.cos(ra2) * (ringR + totalDisp);
      const y2 = ccy + Math.sin(ra2) * (ringR + totalDisp) * (1 - TILT_X * 0.3);
      const depthFactor = 1 + tiltY1 * 0.5;
      const currentTube = tubeR * depthFactor * (0.8 + p.pulseAmp * 0.2 * Math.abs(Math.sin(pulsePhase)));
      const normalAngle = ra1;
      const lightDot = Math.cos(normalAngle - lightAngle) * 0.5 + 0.5;
      const depthLight = (1 + tiltY1) * 0.5;
      const brightness = 0.2 + lightDot * 0.5 + depthLight * 0.3;
      const sss = Math.max(0, Math.sin(pulsePhase)) * p.pulseAmp * 0.4;
      const r = Math.min(255, Math.round(p.color[0] * brightness + sss * 40));
      const g = Math.min(255, Math.round(p.color[1] * brightness + sss * 60));
      const b = Math.min(255, Math.round(p.color[2] * brightness + sss * 50));
      ctx.beginPath();
      ctx.strokeStyle = `rgba(${r},${g},${b},${0.7 + brightness * 0.3})`;
      ctx.lineWidth = currentTube * 2;
      ctx.lineCap = "round";
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // EKG line
    ctx.beginPath();
    ctx.strokeStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${0.5 * p.glowI})`;
    ctx.lineWidth = 1;
    for (let i = 0; i <= SEGMENTS; i++) {
      const a = (i / SEGMENTS) * Math.PI * 2;
      const ra = a + rotAngle;
      const pulsePhase = a - elapsed * p.pulseFreq * Math.PI * 2;
      const d1 = Math.sin(pulsePhase) * p.pulseAmp * tubeR * 0.6;
      const d2 = Math.sin(pulsePhase * 2.3 + 0.5) * p.harm2 * tubeR * 0.5;
      const outerR = ringR + tubeR + 3 + d1 + d2;
      const x = cx + Math.cos(ra) * outerR;
      const y = ccy + Math.sin(ra) * outerR * (1 - TILT_X * 0.3);
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Pulse glow
    const pulseAngle = rotAngle + elapsed * p.pulseFreq * Math.PI * 2;
    const px = cx + Math.cos(pulseAngle) * ringR;
    const py = ccy + Math.sin(pulseAngle) * ringR * (1 - TILT_X * 0.3);
    const pg = ctx.createRadialGradient(px, py, 0, px, py, tubeR * 3);
    pg.addColorStop(0, `rgba(${Math.min(255,p.color[0]+60)},${Math.min(255,p.color[1]+60)},${Math.min(255,p.color[2]+60)},${0.5 * p.glowI})`);
    pg.addColorStop(0.5, `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${0.15 * p.glowI})`);
    pg.addColorStop(1, "transparent");
    ctx.fillStyle = pg;
    ctx.beginPath(); ctx.arc(px, py, tubeR * 3, 0, Math.PI * 2); ctx.fill();

    // Particles
    particles.forEach((pt, idx) => {
      if (idx >= p.pCount) return;
      pt.angle += pt.vAngle + (p.orbit ? p.rotSpeed * 0.3 / 60 : 0);
      const x = cx + Math.cos(pt.angle) * pt.dist;
      const y = ccy + Math.sin(pt.angle) * pt.dist;
      const op = pt.opacity * p.glowI * (0.4 + Math.sin(elapsed * 2 + idx) * 0.3);
      const ptg = ctx.createRadialGradient(x, y, 0, x, y, pt.sz * 2);
      ptg.addColorStop(0, `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${op})`);
      ptg.addColorStop(1, `rgba(${p.color[0]},${p.color[1]},${p.color[2]},0)`);
      ctx.fillStyle = ptg;
      ctx.beginPath(); ctx.arc(x, y, pt.sz * 2, 0, Math.PI * 2); ctx.fill();
    });

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
}

["idle", "online", "thinking", "success", "error"].forEach(s => createAvatar(s, s));
</script>
</body>
</html>
